"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[382],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>h});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(r),h=a,m=d["".concat(s,".").concat(h)]||d[h]||u[h]||i;return r?n.createElement(m,o(o({ref:t},p),{},{components:r})):n.createElement(m,o({ref:t},p))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},6188:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var n=r(7462),a=(r(7294),r(3905));const i={title:"Private Image Registries"},o="Image Registries",l={unversionedId:"config/image_registries",id:"config/image_registries",title:"Private Image Registries",description:"The Raftt environment controller requires access to the image registries from which the workload images are pulled. This is to fetch their metadata, including the entrypoint, args and more. If the images are publicly available (for example, on Dockerhub), nothing needs to be done. Otherwise, it may be necessary to configure access to private registries.",source:"@site/docs/config/image_registries.md",sourceDirName:"config",slug:"/config/image_registries",permalink:"/config/image_registries",draft:!1,tags:[],version:"current",frontMatter:{title:"Private Image Registries"},sidebar:"tutorialSidebar",previous:{title:"Database Seeding",permalink:"/config/db_seeding"},next:{title:"Key Concepts",permalink:"/concepts"}},s={},c=[{value:"ECR",id:"ecr",level:2},{value:"GCR / Google Artifact Registry",id:"gcr--google-artifact-registry",level:2},{value:"Workload Identity",id:"workload-identity",level:3},{value:"Secret",id:"secret",level:3},{value:"Minikube local registry",id:"minikube-local-registry",level:2},{value:"Other registry",id:"other-registry",level:2}],p={toc:c};function u(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"image-registries"},"Image Registries"),(0,a.kt)("p",null,"The Raftt environment controller requires access to the image registries from which the workload images are pulled. This is to fetch their metadata, including the entrypoint, args and more. If the images are publicly available (for example, on Dockerhub), nothing needs to be done. Otherwise, it may be necessary to configure access to private registries."),(0,a.kt)("p",null,"We support several different kinds of authentication, as required by various image registries. Generally, if there are secrets in the namespace with the type ",(0,a.kt)("inlineCode",{parentName:"p"},"kubernetes.io/dockerconfigjson"),", we will try to load them and use them to fetch. Otherwise, you can configure access to registries as follows."),(0,a.kt)("h2",{id:"ecr"},"ECR"),(0,a.kt)("p",null,"ECR access cannot be granted by a long-lived secret value, since tokens are limited to 12 hours. To overcome this, the environment controller has built-in support for the ",(0,a.kt)("inlineCode",{parentName:"p"},"ecr-credential-helper"),", which converts between IAM permissions granted by a role to docker credentials. To configure, add the following to your ",(0,a.kt)("a",{parentName:"p",href:"/config/rafttfile"},".raftt file"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'configure_cred_helper(\n  provider="ecr", \n  registries=["ACCOUNT_ID.dkr.ecr.REGION.amazonaws.com", "MIRROR.INTERNAL.com"])\n')),(0,a.kt)("p",null,"Replacing the hosts in the ",(0,a.kt)("inlineCode",{parentName:"p"},"registries")," param with the correct ones for you."),(0,a.kt)("p",null,"This depends on the environment controller having access to an IAM role which grants read access to the relevant ECR repositories. There are two ways in which this is supported:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"If the nodes have the required access, and pods can access the node metadata server, no further configuration is needed."),(0,a.kt)("li",{parentName:"ol"},"If the nodes do not have the required access, or you have blocked it off from pods, you can:",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Follow ",(0,a.kt)("a",{parentName:"li",href:"https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html"},"https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html")," to create a Kubernetes service account with access to an IAM role."),(0,a.kt)("li",{parentName:"ol"},"Set the following value in the ",(0,a.kt)("a",{parentName:"li",href:"/config/raftt.yml#workloadidentityserviceaccount"},"raftt.yml"),":")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"directOptions:\n  workloadIdentityServiceAccount: <name of service account>\n")),(0,a.kt)("p",null,"This will make the environment controller deployment use the named service account, which will give it the required permissions. For this to take effect, run ",(0,a.kt)("inlineCode",{parentName:"p"},"raftt cleanup")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"raftt connect")," again."),(0,a.kt)("h2",{id:"gcr--google-artifact-registry"},"GCR / Google Artifact Registry"),(0,a.kt)("p",null,"There are two options for supporting GCR repositories. One is to use Workload Identity, and create a Kubernetes service account linked to a GCP service account with the required permissions, and have the environment controller use it. The other is to take the GCP service account's token and create a Kubernetes secret, with which the environment controller will be able to access the registry."),(0,a.kt)("h3",{id:"workload-identity"},"Workload Identity"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Create a service account with the required permissions (i.e. Artifact Registry Reader)."),(0,a.kt)("li",{parentName:"ol"},"Follow ",(0,a.kt)("a",{parentName:"li",href:"https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity#authenticating_to"},"https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity#authenticating_to")," to allow access to the GCP service account permissions from Kubernetes"),(0,a.kt)("li",{parentName:"ol"},"Add the following to your ",(0,a.kt)("a",{parentName:"li",href:"/config/raftt.yml"},"raftt.yml file"),":")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"directOptions:\n  searchLocalDockerRegistry: true\n")),(0,a.kt)("ol",{start:4},(0,a.kt)("li",{parentName:"ol"},"Add the following to your ",(0,a.kt)("a",{parentName:"li",href:"/config/rafttfile"},".raftt file"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'configure_cred_helper(provider="gcp")\n')),(0,a.kt)("p",null,"Which enables the ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-credential-gcr")," helper in the environment controller."),(0,a.kt)("p",null,"For this to take effect, run ",(0,a.kt)("inlineCode",{parentName:"p"},"raftt cleanup")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"raftt connect")," again."),(0,a.kt)("h3",{id:"secret"},"Secret"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Create a GCP service account with the required permissions (i.e. Artifact Registry Reader), and save the token in json format."),(0,a.kt)("li",{parentName:"ol"},"Extract from the GCR secret the email - it should be one of the json fields."),(0,a.kt)("li",{parentName:"ol"},"Run the following, creating a secret allowing access to GCR in the namespace you are using, replacing:",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"NAMESPACE with the relevant namespace"),(0,a.kt)("li",{parentName:"ol"},"SECRET_NAME with a name. This does not matter. Example - \u201cgcr-secret\u201d"),(0,a.kt)("li",{parentName:"ol"},"EMAIL with the email extracted in step 2."),(0,a.kt)("li",{parentName:"ol"},"FILENAME with the filename of the downloaded token.")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'kubectl -n NAMESPACE create secret docker-registry SECRET_NAME \\\n  --docker-server=REGISTRY_URL \\\n  --docker-username=_json_key \\\n  --docker-email=EMAIL \\\n  --docker-password="$(cat FILENAME | base64 -d)"\n')),(0,a.kt)("p",null,"Note: GCR also supports a base64-encoded version of the password, in which case the username should be ",(0,a.kt)("inlineCode",{parentName:"p"},"_json_key_base64"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl -n secrets edit secret SECRET_NAME\n")),(0,a.kt)("h2",{id:"minikube-local-registry"},"Minikube local registry"),(0,a.kt)("p",null,"When using minikube it is possible to build images locally directly to Minikube's registry, using a command like ",(0,a.kt)("inlineCode",{parentName:"p"},"eval $(minikube -p minikube docker-env)"),".  In that case, we need to allow the environment controller to access the internal registry. To do that, add:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"directOptions:\n  searchLocalDockerRegistry: true\n")),(0,a.kt)("p",null,"For this to take effect, run ",(0,a.kt)("inlineCode",{parentName:"p"},"raftt cleanup")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"raftt connect")," again."),(0,a.kt)("h2",{id:"other-registry"},"Other registry"),(0,a.kt)("p",null,"Generally, any registry that is accessed through Kubernetes ImagePullSecrets should work fine, as the environment controller knows to use them if needed."),(0,a.kt)("p",null,"If you have a different requirement, ",(0,a.kt)("a",{parentName:"p",href:"https://raftt.io/contact"},"let us know"),"."))}u.isMDXComponent=!0}}]);